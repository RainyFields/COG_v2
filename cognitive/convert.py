from typing import List, Dict, Any

import numpy as np
import task_generator as tg
import stim_generator as sg
import frame_info as fi


def get_target_value(t):
    # Convert target t to string and convert True/False target values
    # to lower case strings for consistency with other uses of true/false
    # in vocabularies.
    t = t.value if hasattr(t, 'value') else str(t)
    if t is True or t == 'True':
        return 'true'
    if t is False or t == 'False':
        return 'false'
    return t


class TaskInfoConvert(object):
    """Base class for frame_info"""
    task_info: List[Dict[str, Any]]

    def __init__(self, task_example=None, task=None, objset=None):
        " task examples include family, epochs, question, objects, answers"
        " always init frame_info with a single task generated by one tree "
        " combining with a second task should be implemented incrementally"

        if task is None or objset is None:
            if task_example is None:
                raise ValueError("no tasks is provided")
            # initiate frame_info by given task_example
            else:
                self.task_info = [{}]
                self.task_info[0]["task_family"] = task_example["family"]
                self.task_info[0]["is_intact"] = False
                self.task_info[0]["question"] = task_example["question"]
                self.task_info[0]["answers"] = task_example["answers"]

                self._n_epochs = task_example["epochs"]
                self.task_info[0]["task_len"] = self.n_epochs

                cur_task = self.task_info[0]
                self.frame_info = fi.FrameInfo(self.n_epochs,
                                               {0},
                                               cur_task['shareable'],
                                               cur_task['question'],
                                               cur_task['answers'],
                                               objset
                                               )
        else:
            if task.n_frames != objset.n_epoch:
                raise ValueError('Task epoch does not equal objset epoch')

            assert isinstance(task, tg.TemporalTask)

            self.task_info = [{}]
            self.task_info[0]['shareable'] = task.shareable
            self.task_info[0]["task_family"] = task.__class__.__name__
            self.task_info[0]["question"] = str(task)
            self.task_info[0]["answers"] = [get_target_value(t) for t in task.get_target(objset)]
            self.task_info[0]["task_len"] = task.n_frames
            self._n_epochs = self.task_info[0]["task_len"]

            cur_task = self.task_info[0]
            self.frame_info = fi.FrameInfo(self.n_epochs,
                                           {0},
                                           cur_task['shareable'],
                                           cur_task['question'],
                                           cur_task['answers'],
                                           objset
                                           )

    def __len__(self):
        # return number of tasks involved
        return len(self.task_info)

    @property
    def n_epochs(self):
        return len(self.frame_info)

    def index_conv(self, frame_idx, task_idx):
        # return epoch index for given frame index and task index
        return self.frame_info[frame_idx]["relative_task_epoch_idx"][task_idx][0]

    def merge(self, new_task_info, reuse):
        '''

        :param new_task_info: TaskInfoConvert object
        :return: None if merge successful, and the new task if unsuccessful
        '''
        # TODO(mbai): change task instruction here
        # TODO(mbai): frame_info class
        # TODO(mbai): add a flag for pure overlap, not adding new objs
        # TODO: location conflict, feature (shape, color) conflict

        assert isinstance(new_task_info, TaskInfoConvert)
        if len(new_task_info.task_info) > 1:
            raise NotImplementedError('Currently cannot support adding new composite tasks')

        # correct task index in new_task_info
        next_task_idx = len(self.task_info)
        for frame in new_task_info.frame_info:
            frame.relative_tasks = [next_task_idx + i for i, task in enumerate(frame.relative_tasks)]
            for i, task in enumerate(frame.relative_tasks):
                frame.relative_task_epoch_idx[next_task_idx + i] = frame.relative_task_epoch_idx[task].pop()
                task = next_task_idx + i

        # reuse visual stimuli with probability reuse
        if np.random.random() < reuse:
            self.add_new_frame({next_task_idx}, new_task_info)
            # what happens if no visual stimuli on the first
            # shareable frame?

        # create new frames and merge
        else:
            # find the first consecutively shareable frame
            start = self.frame_info.first_shareable
            # add more frames or change lastk? add more frames for now
            if start == -1:
                # queue
                extra_f = len(new_task_info.frame_info)
            else:
                if new_task_info.n_epochs > self.n_epochs:
                    raise NotImplementedError('new task is longer than the existing task')
                extra_f = new_task_info.n_epochs - self.n_epochs - start

            for i in range(extra_f):
                self.add_new_frame({next_task_idx}, new_task_info)

            for old, new in zip(self.frame_info[start, len(self.frame_info)], new_task_info.frame_info):
                old.merge(new)

        self.task_info.append(new_task_info.task_info[0])
        return

    def add_new_frame(self, relative_tasks, new_task_info):
        # add new empty frames
        self.frame_info.frame_list.append(self.frame_info.Frame(
            len(self.frame_info),
            relative_tasks,
            new_task_info.task_info[0]['shareable']
        ))

    def inv_convert(self):
        # inverse the frameinfo to task examples
        examples = []
        for i in range(len(self)):
            examples.append[{}]
            examples[i]["family"] = self.task_info[i]["task_family"]
            examples[i]["epochs"] = self.task_info[i]["task_len"]
            examples[i]["question"] = self.task_info[i]["question"]
            examples[i]["answers"] = self.task_info[i]["answers"]
            examples[i]["is_intact"] = self.task_info[i]["is_intact"]

            inv_frame_index = []  # frame index if involved in task i
            objects_feat = []
            objects = []
            curr_obj = {}
            for j, frame in enumerate(self.frame_info):
                if i in frame["relative_tasks"]:
                    count_i = frame["relative_tasks"].index(i)
                    inv_frame_index.append(j)
                    for obj in self.frame_info[j]["objs"]:
                        for features in ["location", "shape", "color", "is_distractor"]:
                            curr_obj[features] = obj[features]

                        if curr_obj not in objects_feat:
                            curr_obj["epochs"] = [self.frame_info[j]["relative_task_epoch_idx"][count_i]]
                            objects_feat.append(curr_obj)
                            objects.append(curr_obj)
                        else:
                            obj_idx = objects_feat.index(curr_obj)
                            objects[obj_idx]["epochs"].append(self.frame_info[j]["relative_task_epoch_idx"][count_i])
                examples[i]["objects"] = objects
        return examples

    def inv_convert_objset(self):
        '''

        :return: list of objsets
        '''
        # convert frame_info to objset
        pass

    def frame_update(self):
        pass
        # todo: insert/delete frames upon request
